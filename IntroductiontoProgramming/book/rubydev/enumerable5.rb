arr = ['den','jok','loler','joshua']
p arr.map{ |i| i.capitalize }
p arr.map(&:capitalize)

p arr.sort
p arr.sort.reverse

user = [['den',25,1991],['jok',35,1986],['io',121,1901],['spike',18,1998],['calen',55,1961]]
p user.sort
p user.sort_by{ |name| name }
p user.sort_by{ |age| age[1] }
p user.sort_by{ |bd| bd[2] }
p user.sort_by{ |name| name[0].length }
p "="*30
p user.sort_by{ |age| age[1] }.reverse
p user.sort_by{ |bd| bd[2] }.reverse

=begin
Модуль Enumerable предлагает программисту несколько методов для создания новых коллекций из уже существующих выполняя блок кода для каждого элемента родительской коллекции.

Метод map

Это самый простой и часто используемый метод модуля Enumerable. Этот метод создает оригинальную коллекцию применяя переданный блок кода к каждому элементу внутри и возвращает массив результатов:

['joshua', 'gabriel', 'jacob'].map{|name| name.capitalize} #=> ["Joshua", "Gabriel", "Jacob"]
['joshua', 'gabriel', 'jacob'].map(&:capitalize) #=> ["Joshua", "Gabriel", "Jacob"]
Метод map нуждается в блоке кода, который вы можете передать непосредственно как блок или использовать технику с унарным амперсандом, о которой мы уже говорили во второй статье из цикла Магия модуля Enumerable.

Метод sort

Этот метод возвращает массив неизмененных значений из коллекции, но в этом массиве они уже отсортированы определенным образом. Метод sort производит сортировку используя метод <=>. Строки сортируются по алфавиту, а числа по своей величине. Важно чтобы метод <=> был объявлен в классах объектов представляющих сортируемые элементы.

Пример использования:

['joshua', 'gabriel', 'jacob'].sort #=> ["gabriel", "jacob", "joshua"]
[3, 1, 5].sort #=> [1, 3, 5]
Вы так же можете передать блок кода, который будет использоваться для сортировки элементов коллекции, если стандартная сортировка вас не устраивает. Например, вы можете сортировать строки по алфавиту, но начиная не с первой буквы, а с последней:

['joshua', 'gabriel', 'jacob'].sort{|a,b| a.reverse <=> b.reverse} #=> ["joshua", "jacob", "gabriel"]
Метод sort_by

Кратчайший способ сортировки по алфавиту с конца строки (как мы делали в примере выше) заключается в использовании метода sort_by и передачи в него блока кода или использовании техники с унарным амперсандом:

['joshua', 'gabriel', 'jacob'].sort_by{|name| name.reverse} #=> ["joshua", "jacob", "gabriel"]
['joshua', 'gabriel', 'jacob'].sort_by(&:reverse) #=> ["joshua", "jacob", "gabriel"]
Работа этого кода похожа на вызов метода map перед методом sort, так как метод sort_by сортирует не сами по себе элементы коллекции, а результаты использования метода map.

Метод zip

Честно говоря, я не смог придумать хорошего применения этому методу, и я даже не знал о его существовании до написания этой статьи. Метод zip никак не связан с сжатием и архивированием и мне кажется, что лучшее имя для него это «zipper». Вы когда-нибудь замечали на шоссе разделенном двумя полосами эффект застежки-молнии, когда две полосы сливаются в одну?

Метод zip работает на подобный манер:

[1, 2, 3].zip([4, 5, 6]) #=> [[1, 4], [2, 5], [3, 6]]
[1, 2, 3].zip([4, 5, 6], [7, 8, 9]) #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
Он создает оригинальную коллекцию и сливает несколько массивов в показанный выше способ.
=end