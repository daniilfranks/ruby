#http://rubyblog.com.ua

На этот раз рассмотрим очень популярный паттерн - Стратегия (Strategy).

Википедия описывает этот паттерн так:

Стратегия (англ. Strategy) — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путем определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

Написано формальным языком, поэтому давайте разберем на примерах.

Пример #1
Рассмотрим гипотетический метод, который рассчитывает сумму заработной платы после уплаты налогов. Алгоритм расчета отличается от страны к стране, поэтому метод может выглядеть как-то так:

def net_salary(amount, country)
  taxes = case country
    when "Ukraine"
      (amount * 0.05) + 313    
    when "U.S."
      (amount * 0.2) + 100
    when "Poland"  
      amount * 0.3
    else
      0
    end

  amount - taxes
end

net_salary(1000, "Poland")  # => 700.0
net_salary(1000, "Ukraine")  # => 637.0
Как мы видим из примера - для каждой страны применяется своя стратегия расчета налогов.

Основная идея шаблона Strategy - определить набор объектов (стратегий), которые решают одну и ту же задачу - в нашем случае рассчитывают размер налогов, но имеют разную имплементацию. Каждая стратегия не только решает одну и ту же задачу, но и поддерживает единый интерфейс.

Перепишем предыдущий пример используя Strategy:

class UkraineTaxes
  def self.taxes(amount)
    (amount * 0.05) + 313
  end
end

class PolandTaxes
  def self.taxes(amount)
    amount * 0.3
  end
end

class UsTaxes
  def self.taxes(amount)
    (amount * 0.2) + 100
  end
end

class Taxes
  def initialize
    @strategies = {}
    @strategies['Ukraine'] = UkraineTaxes
    @strategies['Poland'] = PolandTaxes
    @strategies['U.S.'] = UsTaxes
  end

  def net_salary(amount, country)
    strategy = @strategies[country]

    strategy ? amount - strategy.taxes(amount) : amount
  end
end

Taxes.new.net_salary(1000, "U.S.") # => 700.0
Для каждой страны мы создали класс, который отвечает на запрос .taxes. В метод .taxes мы вынесли всю логику, которая определяет размер налогов. В initialize класса Taxes мы определяем список доступных стратегий. В методе net_salary мы выбираем стратегию на основе полученного параметра coutry. Если стратегию определить не удалось, просто возвращаем amount.

Если имплементация стратегии - это одна строка кода (как в нашем случае), то можно обойтись даже без создания отдельных классов под каждую из них. На помощь приходят лямбды. С ними наш код станет гораздо лаконичнее:

class Taxes
  attr_reader :amount

  def initialize(amount)
    @amount = amount

    @strategies = {}
    @strategies['Ukraine'] = -> { (amount * 0.05) + 313 }
    @strategies['Poland'] = -> { amount * 0.3 }
    @strategies['U.S.'] = -> { (amount * 0.2) + 100 }        
  end

  def net_salary(country)
    strategy = @strategies[country]

    strategy ? amount - strategy.call : amount
  end

end

Taxes.new(1200).net_salary("U.S.") # => 700.0
Если вы еще не работали с лямбдами, не пугайтесь. Если обьяснить слишком упрощенно, то лямбды - это небольшие кусочки кода, которые можно сохранить в переменную и выполнить (strategy.call) когда вам это необходимо. Кроме того, лямбды "затягивают" в себя всю область видимости в которой они создаются.

Такой подход позволяет отделить имплементацию каждой стратегии от места, где она используется. Не зря полиморфизм - это одна из основных идей ООП: каждая стратегия имеет единый интерфейс и мы можем уверенно вызывать strategy.call зная, что получим результат, но даже не зная какая именно стратегия отработает.

Очень важно уметь находить места, в которых можно применить этот паттерн. Поэтому хочу привести еще один пример использования Strategy.

Пример #2
Рассмотрим пример, в котором мы получаем данные со стороннего API, и дальше, в зависимости от полученного респонса, решаем как его обрабатывать.

Ответ - это обьект, который отвечает на status и data. Соответственно, в status может быть: success, error или fail. Если это success - используем response.data, если error - выводим response.error_message, а если fail - говорим что произошло что-то страшное :)

def show
  response = external_api.get(params[:id])

  return handle_error if response.status == "error"
  return handle_fail if response.status == "fail"

  if response.status == "success"
    "Successful response: #{response.data}"
  end
end

def handle_error
  puts "Error: #{response.error_message}"
end

def handle_fail
  puts "Request Failed"
end
Код я упростил, но проблема очевидна. Мы получаем response и должны решить как его обрабатывать. Снова есть возможность применить паттерн Strategy.

Итак, мы уже знаем что логику обработки нужно вынести в отдельные классы или что-то, что имело бы единый интерфейс (в том числе и лямбды). А определять стратегию будем, очевидно, по response.status. Вполне возможна такая имплементация:

class ResponseHandler
  def self.handle(response, strategies)
    strategies[response.status.to_sym].call
  end
end

def show
  response = external_service.get(params[:id])

  on_success = -> { "Successful response: #{response.data}" }
  on_error = -> { "Error: #{response.error_message}" }
  on_fail = -> { "Request Failed" }

  ResponseHandler.handle(response, success: on_success, error: on_error, fail: on_fail)
end
Давайте рассмотрим этот код:

Мы создали класс ResponseHandler, который будет обрабатывать ответы сторонних API.
Также, ResponseHandler принимает стратегии, которые нужно выполнить в зависимости от статуса полученного в ответе.
Все стратегии имеют единый интерфейс и отвечают на метод .call, так как это лямбды.
Имея стратегии с единым интерфейсом и обьект response, класс ResponseHandler без проблем может запустить необходимую стратегию обработки: strategies[response.status.to_sym].call
На мой взгляд получилось весьма неплохо. ResponseHandler можно расширять: например, добавить базовые стратегии обработки on_fail, чтобы не передавать одну и ту же лямбду каждый раз для других реквестов.

Со временем стратегии можно вынести в отдельные классы и отказаться от лямбд. Этот подход весьма гибок и позволяет добавлять новые стратегии с минимальными усилиями. Единственное что нужно - чтобы стратегия отвечала на один и тот же метод, который будет вызывать хендлер.

Не забывайте: если в коде есть много if..else или case...when, присмотритесь, может у вас есть отличный шанс использовать шаблон Strategy.

Если вам необходимо принимать решение о том, какой алгоритм использовать в зависимости от условий - попробуйте использовать стратегии.