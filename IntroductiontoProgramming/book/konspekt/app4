#http://rubyblog.com.ua

lambda
Вообще говоря, в лямбдах и проках нет ничего сложного. Лямбда - это просто функция, которая не имеет названия. Это, так называемая, анонимная функция. Так, как практически все в Ruby это обьекты, то и лямбда - это тоже обьект у которого есть метод call, который как раз и вызывает анонимную функцию. Пример:

hello = lambda { puts "Hello" }
hello.call # => Hello
Все просто, не так ли?) Мы "сохранили" блок кода в переменную hello и вызвали его hello.call тогда, когда нам это необходимо. Хотите передать параметр - нет проблем:

hello = lambda { |word| puts word }
hello.call("Hello") # => Hello
Если вызвать эту лямбду, но не передать параметр - получим ошибку:

hello = lambda { |word| puts word }
hello.call("Hello") # => Hello
hello.call # => wrong number of arguments (0 for 1) (ArgumentError)
Таким образом мы видим, что лямбда ведет себя как простой метод и если ей не передать всех необходимых параметров - она не выполнится и поругается на wrong number of arguments.

Лямбда ведет себя как простой метод и внутри других методов. Рассмотрим пример:

def say_hi
  l = lambda { "Hi from lambda" }

  puts "Lambda will say hi:"
  puts l.call
  puts "It worked!"
end

say_hi

# Lambda will say hi:
# Hi from lambda
# It worked!
Как мы видим - вызов лямбды никак не влияет на ход выполнения функции say_hi, лямбда просто вернула свое значение и код say_hi продолжил выполняться дальше.

Еще один важный момент - лямбда "затягивает" в себя всю область видимости, в которой она была обьявлена. В нашем примере это значит, что все переменные, которые были обьявлены перед лямбдой внутри метода say_hi будут доступны лямбде:

def say_hi
  x = 10
  l = lambda { "I see x = #{x}" }
  l.call
end

puts say_hi # => I see x = 10

Так, как переменные области видимости доступны внутри лямбды - она так же может их изменять. Но переменные, которые обьявлены только внутри лямбды - разрушаются после выполнения и во внешнюю область видимосты не попадают:

def count
  counter = 1
  l = lambda do
    counter += 1
    lambda_var = 100
  end
  l.call
  puts counter # => 2
  puts defined?(lambda_var) # => nil
end

Как мы видим, вызов лямбды изменил переменную counter метода count. А переменная lambda_var живет только внутри лямбды и снаружи недоступна. Следует сразу сказать, что такую же область видимости имеют и Proc'и.

Лямбду можно обьявить как воспользовавшись ключевым словом lambda, так и сокращенным вариантом ->. Если увидите ->, знайте что это обычная лямбда:

# without params
l = -> { puts "Hello" }
l = lambda { puts "Hello" }

# with params
l = -> (word) { puts word }
l = lambda { |word| puts word }
Теперь перейдем к интересной части. Давайте посмотрим, обьектом какого класса является лямбда:

puts lambda { |word| puts word }.class # => Proc
Да, lambda - это частный случай Proc'а. Так что, теперь мы можем двигаться в сторону Proc.

Proc
Proc - это сокращение от procedure и да, это тоже блок кода, который мы можем сохранить в переменную и вызвать воспользовавшись методом call:

# without param
p = Proc.new { puts "Hello" }
p.call # => Hello

# with param
p = Proc.new { |word| puts word }
p.call("Hello") # => Hello
Также есть и сокращенный вариант записи. Вместо Proc.new можно воспользоваться ключевым словом proc:

# without param
p = proc { puts "Hello" }
p.call # => Hello

# with param
p = proc { |word| puts word }
p.call("Hello") # => Hello
Проки, как и лямбды, тоже затягивают в себя область видимости и могут изменять переменные:

def say_hi
  x = 10
  p = Proc.new { "I see and can change x too! x = #{x}" }
  p.call
end

puts say_hi # => I see x = 10 too!

Чем отличаются
Предлагаю теперь рассмотреть, в чем же все-таки отличие между этими блоками кода, которые мы сохраняем в переменную и вызываем с помощью метода #call:

1. Лямбды строго контролируют количество параметров, которое им передают, а проки - нет.

l = ->(a, b) { puts "#{a} and #{b}" }
p = Proc.new { |a, b| puts "#{a} and #{b}" }
Имеем лябмду и прок, которые принимают по два параметра. Попробуем вызвать лямбду всего с одним параметром:

l.call("foo") # => wrong number of arguments (1 for 2)
Лямбда выпадает с ошибкой, так как передали один параметр, а не два. Теперь Proc:

p.call("foo") # => foo and
Прок отработал. Первый параметр он установил в "foo", а второй в nil. Таким образом, лямбды более строги к передаваемым параметрам, а проки - нет. Те параметры, которые небыли переданы - прок устанавливает в nil.

Cледует упомянуть, что и проки и лямбды, как и методы, принимают дефолтные значения для аргументов:

l = ->(word = "default") { puts word }
l.call # => default

p = proc { |word = "default"| puts word }
p.call # => default
Если мы определили дефолтные значения для параметров, то можем вызывать и лямбду и прок не передавая ничего, в данном случае, будут использованы дефолтные параметры.

2. return из лямбды - просто возвращает значение, а return из Proc возвращает значение из области видимости (метода), в которой он был обьявлен.

Пример с лямбдой мы уже рассматривали:

def do_math
  sum = ->(a, b) { return a + b }
  result = sum.call(2, 2)
  "Result of 2+2 is #{result}"
end

do_math # => Result of 2+2 is 4
Даже после вызова sum.call(2, 2), код внутри функции do_math продолжил выполняться и мы вывели красивую строку с результатом. То есть return с лямбды работает так, как работал бы вызов любой другой функции.

А вот с Proc все немного иначе:

def foo
  p = Proc.new { return "Returned value from Proc" }
  p.call
  "Return from do_math"
end

puts foo # => Returned value from Proc
Как только мы вызвали p.call, прок перехватил выполнение метода foo на себя и после выполнения return, вернул свое значение и закончил выполнение метода foo. На строку "Return from do_math" мы уже не попали. Так, как результатом выполнения функции foo стал результат выполнения прока.

Проки и лямбды как блоки
В прошлой статье мы рассмотрели как методы могут принимать блоки. А теперь пришли к выводу, что лямбды и проки - это те же блоки кода, которые мы сохраняем в переменную. Возникает вопрос - можем ли мы передавать Proc или лямбду в виде блока в метод? Ответ - конечно же можем.

Рассмотрим пример метода, который обязательным параметром принимает строку, а также может принимать и блок. Если передана только строка - он ее выводит как есть. Если передан блок, который декорирует строку - вызывается этот блок:

def decorate(str)
  block_given? ? yield(str) : str
end

puts decorate("Bare string") # => Bare string
puts decorate("foo") { |str| "Decorated string: #{str}" } # => Decorated string: foo
Мы можем использовать Proc в качестве блока, который передаем в метод decorate:

def decorate(str)
  block_given? ? yield(str) : str
end

p = Proc.new { |str| "Decorated string #{str}" }
puts decorate("foo", &p) # => Decorated string: foo
Как видим, мы воспользовались конструкцией &p, которая говорит о том, что мы хотим передать наш Proc p в виде блока для метода decorate. Замечу, что прок в виде блока передан последним параметром.

Лямбду также можно передать в виде блока (для нее автоматически будет вызван метод to_proc):

func = ->(num) { "#{num}!" }
[1,2,3].map(&func) # => ["1!", "2!", "3!"]

Надеюсь предыдущие примеры были понятны. Потому что если вы поняли как передавать проки в виде блоков - то следующий пример будет так же понятен.

Я думаю все вы сталкивались с подобной формой записи:

["foo", "bar", "baz"].map(&:upcase) # => ["FOO", "BAR", "BAZ"]
Этот код, проходит по каждому элементу массива и вызывает метод .upcase. Его можно переписать и так:

["foo", "bar", "baz"].map { |x| x.upcase }
Но для краткости записи все пользуются краткой формой:

["foo", "bar", "baz"].map(&:upcase)
Давайте развеем "магию" данного кода и поэтапно разберемся что происходит. Итак:

Метод map принимает блок в который передает каждый элемент массива
Амперсанд & говорит о том, что мы хотим передать Proc в виде блока для map.
Мы передаем символ :upcase для которого автоматически вызывается метод to_proc. Если не передать непосредственно Proc, то Ruby попытается привести то, что мы передали к проку вызвав to_proc.
Выполняется :upcase.to_proc, что создает прок вида: proc { |x| x.upcase }
После чего этот прок передается в виде блока в map.
Таким образом мы вызываем у каждого элемента массива метод #upcase.

Summary
Упрощенно: лямбды и проки - это блоки кода, которые сохраняются в переменную и могут быть вызваны методом "#call".
Лямбды контролируют количество параметров, которые переданы, а проки нет. Проки просто заменяют недостающие параметры на nil.
Если сделать return из прока - он вернет значение с той области видимости в которой был вызван. Return с лямбды ведет себя так же, как ведет себя return из простого метода.
Proc можно передать в виде блока воспользовавшись &. Если передать другой тип, то для него будет вызван метод to_proc.