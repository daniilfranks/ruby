#http://rubyblog.com.ua
each_with_object имеет много общего с inject, но все-же между ними есть одно важное отличие. Если вы не читали статью об inject - обязательно прочтите и возвращайтесь.

Итак, в случае inject в memo передается результат, который возвращает блок кода. Рассмотрим этот пример:

roles = ["user", "admin", "guest"]
roles_hash = roles.inject({}) { |hash, role| hash.update(role => true) } 
Мы использовали здесь метод update, который возвращает хеш с только что добавленной парой ключ-значение:

{}.update(foo: "bar") # => {:foo=>"bar"}
Если бы мы попробовали сделать вот так:

roles = ["user", "admin", "guest"]
roles_hash = roles.inject({}) { |hash, role| hash[role] = true } 
Получаем бы ошибку:

# NoMethodError: undefined method `[]=' for true:TrueClass
А все почему? Потому что результат выполнения hash[role] = true равен присвоенному значению, то есть true. Блок возвращает это значение и оно передается в следующую итерацию как memo. После чего мы у true пытаемся вызвать true[role] = true, что недопустимо.

Хорош еще один пример, где мы выбирали тех пользователей, чей возраст больше 21 года:

users.reduce([]) do |names, user| 
  names << user.name if user.age > 21
  names
end
Здесь та же ситуация, мы обязаны вернуть массив names из блока, так как результат выполнения блока будет записан в names следующей итерации.

Вот для таких ситуаций лучше всего подходит each_with_object. Он так же проходит по всем элементам коллекции, получает начальное значение в виде аргумента, оперирует двумя параметрами блока: memo и элементом коллекции и возвращает memo по окончанию выполнения.

Основное отличие в том, что он не передает результат выполнения блока в memo следующей операции. memo передается в каждую итерацию независимо от того, что вернул блок предыдущей итерации.

Используя each_with_object первый пример можно переписать так:

roles = ["user", "admin", "guest"]
roles_hash = roles.each_with_object({}) { |role, hash| hash[role] = true } 
Так, как нам не нужно возвращать memo из блока для подстановки в следующую итерацию - мы просто меняем hash привычным образом и он в измененном виде переходит в следующую итерацию.

Обратите внимание, что легко запомнить очередность параметров в методах типа each_with_index, each_with_object: первым идет each - элемент коллекции, а вот index или object передается вторым параметром:

[1, 2, 3].each_with_index { |element, index|  .... }
[1, 2, 3].each_with_object { |element, object|  .... }
Перепишем второй пример с выборкой имен пользователей старше 21 года:

users.each_with_object([]) do |user, names| 
  names << user.name if user.age > 21
end
В данном случае та же история. Мы избавились от явного возвращения names. Так, как массив names нам доступен в каждой итерации, вне зависимости от того, что возвращает блок.

Если подитожить: inject идеально подходит в том случае, если ваш код внутри блока возвращает memo, которое должно пойти в следующую итерацию. Если вам необходимо пробрасывать memo автоматически, вне зависимости от того что возвращает блок - используйте each_with_object.