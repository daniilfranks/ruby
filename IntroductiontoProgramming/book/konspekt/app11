#http://rubyblog.com.ua
Всем привет. Сегодня хочу поговорить о таком полезном подходе при разработке, как мемоизация (memoization).

Но, для начала, немного поговорим о Ruby и его возможностях. Часто, нам необходимо присвоить результат выполнения функции какой-то переменной. А если результат выполнения функции false или nil - присвоить какое-то значение по-умолчанию.

Покажем для начала возможный, но очень некрасивый код:

if @page.title
  site_title = @page.title
else
  site_title = "Blog about Ruby and Ruby On Rails"
end
Представим, что в данном примере @page.title может быть nil, если пользователь не ввел заголовок страницы. Мы проверяем - если заголовок не nil - используем его, если nil - возвращаем значение по-умолчанию.

Теперь рассмотрим, как более красиво реализовать эту логику:

site_title = @page.title || "Blog about Ruby and Ruby On Rails"
Если описать подобный код словами, то можно сказать так: если @page.title не равно nil или false, присваиваем его значение переменной site_title, иначе - берем дефолтную строку.

Запоминаем эту возможность языка Ruby и переходим собственно к мемоизации.

Вот как описывает мемоизацию Википедия:

Мемоизация (запоминание, от англ. memoization (англ.) в программировании) — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ. Перед вызовом функции проверяется, вызывалась ли функция ранее:

если не вызывалась, функция вызывается и результат её выполнения сохраняется;
если вызывалась, используется сохранённый результат.
Итак, наша задача убедиться, что функция, выполняя какие-то действия, сохраняет результат и при повторном вызове - возвращает сохраненный результат не производя повторных вычислений.

Рассмотрим для начала код, который не использует мемоизацию. В ApplicationController мы добавили метод current_user, который используют все контроллеры приложения для того, чтобы получать залогиненного пользователя:

class ApplicationController < ActionController::Base
  def current_user
    User.find(session[:user_id])
  end
end
Этот метод делает выборку данных каждый раз (!), когда мы вызываем метод current_user, нагружая тем самым базу данных ненужными запросами. Если добавить мемоизацию, то мы будем выбирать юзера только один раз (при первом вызове метода current_user).

Достигается это очень простым кодом, который похож на тот, который я привел в начале поста, а именно:

class ApplicationController < ActionController::Base
  def current_user
    @current_user ||= User.find(session[:user_id])
  end
end
Опять же, если описать словами, то получается так: если переменная класса @current_user равна false или nil - попытаться найти пользователя, если пользователь уже найден и переменная @current_user заполнена - вернуть значение @current_user.

Таким образом, мемоизация в Ruby достигается простым трюком с использованием переменной класса и конструкцией вида: ||=.

Если ваш метод, к которому вы хотите добавить мемоизацию не ограничивается одной строкой - не проблема, всегда можно воспользоваться конструкцией begin..end:

def roles_with_users_count
  @roles ||= begin
    Role.all.inject({}) do |hash, role|
       hash.update(role.name => User.with_role(role).count)
    end
  end
end
Код, результат которого мы кешируем не так важен, но важно помнить, что если у вас больше одной строки и вы хотите добавить мемоизацию - используйте begin..end

Используйте мемоизацию: если вы делаете сложные расчеты, или выборку из базы данных и вам достаточно сделать это один раз. Это своеобразное кеширование результатов выполнения функции в памяти.

Не следует использовать мемоизацию в методах, которые принимают параметры. Ведь в данном случае результаты вычислений могут меняться в зависимости от полученных параметров (впрочем даже для этих случаев есть варианты).

Также, не следует применять мемоизацию в методах с переменными класса, например:

# не делайте так
def full_name
  @full_name ||= "#{@first_name} #{@last_name}"
end

@first_name = 'Sergey'
@last_name = 'M'

puts full_name # => "Sergey M"

@first_name = 'John'
@last_name = 'Doe'

puts full_name # => "Sergey M"
Переменные изменились, но мы уже закешировали их первоначальное значение в переменную @full_name и возвращаем ее каждый раз при вызове full_name вне зависимости от текущего состояния @first_name и @last_name.

Удачи в использовании мемоизации в ваших проектах!

PS: Если вам немного непонятны примеры со статьи, хорошо разобраться в подходе помогут irb и более простые примеры:

a = nil || "foo" # => "foo"
b = false || "bar" # => "bar"
c = "foo" || "bar" # => "foo"
Или вот такой пример:

def get_number
  puts "getting number"
  10
end

def memoized_number
  @number ||= get_number
end
При первом вызове memoized_number мы выполним get_number, а следовательно увидим и "getting number", после чего переменной @number будет присвоено значение 10. При повторном вызове memoized_number, мы уже не увидим "getting number", так как будет использовано кешированное значение переменной @number.