Наиболее простой способ приведения к массиву в Ruby

def initialize(items)
  @items = Array(items)
  ...
end

Если items это массив - он и останется массивом, а если это, например, целочисленное значение - оно завернется в массив, чего нам и нужно.

Module#prepend в Ruby 2.0

Чтобы понять что делает Module#prepend, предлагаю сначала рассмотреть простой пример того, как работает method lookup в Ruby.

В случае если у нас простое наследование и метод есть в родительском классе, но нет в основном классе:

class Human
  def hi
    "Hi from Human!"
  end
end

class Man < Human
end

puts Man.new.hi  # => Hi from Human!
Это простейший и очевидный случай. Вызывается метод в родительском классе Human.

Рассмотрим более интересный пример, когда метод с одинаковым названием есть как в родительском классе, так и в модуле, который мы инклудим:

class Human
  def hi
    "Hi from Human!"
  end
end

module Greetable
  def hi
    "Hi from Module!"
  end
end

class Man < Human
  include Greetable
end

puts Man.new.hi  # => "Hi from Module!"
Как видим из результата, в данном случае вызывается метод hi из модуля Greetable. Следовательно, в иерархии модуль имеет приоритет выше, нежели родительский класс. Это подтверждает и метод ancestors:

puts Man.ancestors.inspect # => [Man, Greetable, Human, ...]
Здесь мы видим, что сначала идет сам класс, затем модуль и только потом родительский класс.

Ruby сначала будет искать метод hi в самом классе Man, если не найдет - пойдет искать в модуль Greetable и только потом в родительский класс Human.

Теперь возвращаемся к Module#prepend. Давайте рассмотрим что произойдет если мы заменим include Geetable на prepend Greetable.

Лучшее обьяснение дает все тот же метод ancestors:

puts Man.ancestors.inspect # => [Greetable, Man, Human, ...]
Как мы видим, теперь модуль находится в самом начале цепочки. Это означает, что даже если мы добавим метод hi непосредственно в основной класс Man - он не будет вызван, так как первое место куда идет интерпретатор - это модуль Greetable.

Простой пример который это показывает:

module Greetable
  def hi
    "Hi from Module!"
  end
end

class Man
  prepend Greetable

  def hi
    "Hi from Man"
  end
end

puts Man.new.hi  # => "Hi from Module!"

puts Man.ancestors.inspect # => [Greetable, Man, Object]
С возможностью кардинально менять method lookup для ваших классов нужно работать очень осторожно, так как подобный код не совсем очевиден. А если вам и приходится использовать prepend, то задумайтесь - может можно изменить дизайн ваших классов так, чтобы сделать код более очевидным.

Тем не менее, уверен, что бывают случаи когда prepend может быть полезен, а потому нужно знать что такая возможность есть и использовать при необходимости.