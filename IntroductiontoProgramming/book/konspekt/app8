Закон Деметры и delegate в Rails

Если вкратце - это набор правил, которые ограничивают знания модулей друг о друге и тем самым позволяют снизить зависимость модулей друг от друга.

Вот формулировка от Википедии:

Говоря упрощённо, каждый программный модуль:

должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.
должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
обращаться только к непосредственным «друзьям».
Аналогия из жизни: Если Вы хотите, чтобы собака побежала, глупо командовать ее лапами, лучше отдать команду собаке, а она уже разберётся со своими лапами сама.

Основной идеей является то, что объект должен иметь как можно меньше представления о структуре и свойствах чего угодно (включая собственные подкомпоненты).

Такое описание дает довольно неплохое представление общих идей данного закона: компоненты нашего приложения должны знать как можно меньше о деталях реализации других компонентов.

Теперь вернемся к ActiveRecord и связям между моделями. Рассмотрим пример, который очень часто вам встретится:

class User < ActiveRecord::Base
  has_one :address
  has_many :orders
end

class Address < ActiveRecord::Base
  belongs_to :user
end

class Order < ActiveRecord::Base
  belongs_to :user
end
Ничего необычного здесь: пользователь имеет один адрес, и может иметь много заказов. В свою очередь адрес и заказ принадлежат пользователю.

Вполне вероятно, что во view вы увидите код, похожий на этот:

<%=order.user.name %>
<%=order.user.address.street %>
<%=order.user.address.city %>
<%=order.user.address.country %>

Благодаря тому, что ActiveRecord позволяет удобно работать с ассоциациями - мы часто нарушаем закон Деметры таким кодом.

Ведь в данном случае из обьекта Order мы получили знания о пользователе, адресе и улице на которой он живет. Не слишком ли много заказ знает о пользователе? :)

Если перефразировать закон Деметры для нашего случая - то мы не должны использовать больше одной точки в коде. Например: order.user_name вполне хороший код, так как из обьекта order мы получаем доступ непосредственно к данным пользователя. Но это, конечно работает в идеальном мире. Нам же, нужно отталкиваться от того, что этих "точек" в коде должно быть как можно меньше.

Итак, мы могли бы переписать код подобным образом:

class User < ActiveRecord::Base

  has_one :address
  has_many :orders

  def street
    address.street
  end

  def city
    address.city
  end

  def country
    address.country
  end

end

class Order < ActiveRecord::Base

  belongs_to :user

  def user_name
    user.name
  end

  def user_street
    user.street
  end

  def user_city
    user.city
  end

  def user_country
    user.country
  end

end


Благодаря таким изменениям, код во view теперь будет выглядеть так:

<%=order.user_name %>
<%=order.user_street %>
<%=order.user_city %>
<%=order.user_country %>
Давайте задумаемся что нам дает подобный подход. Из плюсов - мы теперь не пересекаем явным образом границы двух обьектов используя ассоциации (order.user...), мы делаем это более абстрактно - используя методы-обертки для каждого атрибута.

Минусом такого подхода как раз и являются эти методы - которые захламляют наши классы. Кроме того - если потребуется добавить еще один атрибут - нам нужно лезть в несколько классов. Поддерживать такой код весьма проблематично.

На помощь приходит метод delegate, который нам предоставляет Rails.

Чтобы долго не расписывать что он делает - давайте рассмотрим то, как мы можем переписать предыдущий пример кода, используя delegate:

class User < ActiveRecord::Base

  has_one :address
  has_many :orders

  delegate :street, :city, :country, to: :address

end

class Order < ActiveRecord::Base

  belongs_to :user

  delegate :name, :street, :city, :country, to: :user, prefix: true

end

Выглядит гораздо лучше, не так ли?

Итак, давайте разберемся что делает delegate для модели User: Он передает все вызовы методов :street, :city, :country обьекту address (который у нас есть благодаря ассоциации has_one)

Таким образом если мы вызываем current_user.street - на самом деле отработает current_user.address.street, так как мы делегировали вызов street обьекту address.

В случае с Order, происходит то же самое, но с одной поправкой: мы передали параметр prefix: true. Это означает, что всем методам которые мы делегируем будет добавлен префикс user. Следовательно у Order'a будут доступны методы: user_name, user_street, user_city и user_country.

Теперь order.user_name вызовет order.user.name. А order.user_street вызовет order.user.street, который в свою очередь делегировал этот метод на user.address.street.

Таким образом, делегируя методы другим обьектам мы не нарушаем закон Деметры и не пишем обертки для всех атрибутов, к которым хотим получить доступ.

Попробуйте применить такой подход в следующий раз, когда увидите подобную цепочку вызовов: order.user.address.street, ведь гораздо понятнее выглядит такой код: order.user_street.

PS: Если же вы работаете с чистым Ruby (без Rails), для применения подобного подхода советую посмотреть на модуль Forwardable, который также позволяет делегировать методы обьектам внутри класса.