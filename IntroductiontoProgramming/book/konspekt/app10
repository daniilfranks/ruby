inject для работы с коллекциями в Ruby

О том, что мы применяем каждый день работая с массивами и хешами. О том, где используется модуль Enumerable.

Вообще, очень рекомендую посмотреть на этот модуль, так как он предоставляет очень много полезных методов, таких как: map, select, inject, each_with_object и так далее.

В данной заметке хочу остановиться именно на inject.

Enumerable#inject
Этот метод очень широко используется. Для начала рассмотрим самый простой пример, а потом попробуем разобраться как он работает:

[1, 2, 3, 4, 5].inject(0) { |memo, i| memo + i } # => 15
Итак, как видно из результата - мы посчитали сумму всех элементов массива. Как мы этого достигли? Давайте смотреть:

inject проходит по всем элементам коллекции
блок который вызываетinject имеет два параметра: сам элемент и memo
изначальное значение memo передается параметром, в нашем случае 0: inject(0)
результат выполнения блока записывается в memo для следующей итерации
Знаю, звучит немного сложно, но если рассмотреть этот процесс шаг за шагом , то становится более понятно. Первая итерация будет выглядеть так:

# memo, благодаря inject(0), равняется 0, а первый элемент массива = 1
[1, 2, 3, 4, 5].inject(0) { |0, 1| 0 + 1 } # => 1. Теперь для следующей итерации memo = 1

# вторая итерация, следующий элемент массива и memo = 1 
[1, 2, 3, 4, 5].inject(0) { |1, 2| 1 + 2 } # => 3. Теперь memo = 3

# третья итерация
[1, 2, 3, 4, 5].inject(0) { |3, 3| 3 + 3 } # => 6. Для следующей итерации memo = 6 

# и так далее
Надеюсь теперь стало немного понятнее. Но, на всякий случай, еще раз:

аргумент, который мы передаем в inject является начальным значением для memo (название переменной конечно же можно менять на то, которое вам нравится больше. В нашем случае переменную можно было бы назвать не memo, а accumulator, например)
значение, которое возвращает блок - передается как memo в следующую итерацию
inject проходит по всем элементам коллекции
результатом выполнения метода inject является последнее значение memo
Давайте рассмотрим более интересный пример, который может вам встретиться в повседневной работе. У вас есть массив ролей пользователя, а вам нужно получить хеш, в котором ключ - это роль, а значение равно true

Трансформировать эти данные ["user", "admin", "guest"] в такой формат: {"user" => true, "admin" => true, "guest" => true}

Если бы мы не знали о существовании inject, код получился бы примерно таким:

roles = ["user", "admin", "guest"]
roles_hash = {}
roles.each { |role| roles_hash[role] = true }
Но теперь мы знаем, что мы можем сделать это более красиво:

roles = ["user", "admin", "guest"]
roles_hash = roles.inject({}) { |hash, role| hash.update(role => true) }
Заметить место, где можно воспользоваться inject всегда довольно просто: если вы сначала обьявляете пустой хеш или массив, а потом в следующих строках проходите циклом и наполняете его следуя какой-то логике, знайте - это можно сделать проще.

Давайте рассмотрим еще несколько примеров.

Например, у вас есть массив обьектов пользователей. Каждый пользователь имеет аттрибуты: age и name. Вам нужно собрать в массив имена пользователей, чей возраст больше 21 года. Это делается довольно просто

users.reduce([]) do |names, user| 
  names << user.name if user.age > 21
  names
end
Разве не прекрасно? В одном небольшом кусочке кода реализован такой обьем логики. Мы проходим по всем пользователям, находим тех, кому больше 21 года, берем его имя и записываем в массив имен. Следует заметить, что так как names - это массив, то результатом выполнения блока тоже должен быть массив. Поэтому второй строкой в блоке мы просто возвращаем массив names.

Рассмотрим еще один пример. Допустим, у нас есть значения баланса до совершения платежей, суммы всех платежей и значение баланса после платежей. Нам нужно проверить правильно ли изменился баланс.

Входные данные:

balance_before = 1000
balance_after = 200
transactions = [200, 100, 200, 100, 50, 150]
Теперь вы догадываетесь как можно реализовать эту проверку, не так ли?

balance_after == transactions.inject(balance_before) { |balance, amount| balance - amount }
Одна строка! Но Ruby не может нам не предложить сделать даже эту строку еще короче. Если все, что у вас находится в блоке сводится к одному действию между элементом и memo, существует более короткая форма записи, а именно:

balance_after == transactions.inject(balance_before, :-) # => true
На вид как смайл, но на самом деле мы просто передаем в виде символа метод, который мы хотим вызвать для memo и элемента коллекции, в нашем случае это "-".

А код из примера в котором мы считаем сумму элементов массива можно переписать вот так:

[1, 2, 3, 4, 5].inject(0, :+)
О таком сокращении нужно помнить, и использовать там где это уместно. Но о читаемости кода так же не стоит забывать.

Очень советую пользоваться методом inject. Сначала это может показаться сложновато, но если вникнуть - можно существенно сократить обьем кода и решать относительно сложные задачи в одну-две строки кода.

PS: Как часто бывает, у Ruby есть несколько названий для одного и того же метода. Для inject есть алиас, которым пользуются многие - это reduce. Так что, если увидите reduce - знайте, что это и есть inject, который мы с вами рассматривали.