http://ruby-doc.org/core-2.3.1/
Юкихиро Мацумото 1993
Интерпретатор - это программа, переводящая код в машинные команды, понятныекомпьютеру.

===============================ООП===================================
Парадигма программирования - это система идей и понятий, определяющих стильнаписаниякомпьютерныхпрограмм. Парадигмы программирования не являются взаимоисключающими и, следовательно,могутсочетаться. Объектно-ориентированная парадигма (ООП) - это парадигма программирования,вкоторойосновнымиконцепциямиявляютсяпонятияобъектовиклассов. 
ООП развивает идеологию процедурного программирования, где данные и подпрограммы(процедурыилифункции)ихобработкиформальнонесвязаны. ООП - это не только набор конкретных методик, а также еще и философия проектирования приложений. Как и любая сложная парадигма, ООП состоит из нескольких уровней понимания. Следует заметить, что применение объектноориентированного языка Ruby не означает, что код автоматически становится объектно-ориентированным - требуется явная реализация и использование объектно-ориентированныхконцепций. ОсновныепонятияООП-этоабстракция,класс,объект,свойство,метод,инкапсуляция,наследованиеиполиморфизм. Объектно-ориентированныйдизайн-этодисциплина,описывающаяспособы (варианты) определения объектов и их взаимодействия для решения проблемы, котораяопределенаиописанавходеобъектно-ориентированногоанализа.Поведение программы формируется с помощью группы объектов, обменивающихся сообщениямидлявзаимодействия.

Абстракция:
Абстрагирование - это способ выделить существенные свойства и игнорировать несущественные. Соответственно, абстракция - это набор выделенных существенныхсвойств. Существенныесвойства-этосвойства,которымисущностьобязанаобладать, чтобыбытьименноэтойсущностью.Несущественныесвойства-свойства,обладаниекоторыминеобязательно. С точки зрения сложности, главное достоинство абстракции в том, что она позволяетигнорироватьнесущественныедетали(неимеющиезначениядляпрограммы).Абстракция-этоодинизглавныхспособовборьбысосложностьюреальногомира.

Класс:
Класс-этоабстрактная(виртуальная)модель(абстрактныйтипданных),еще несуществующей сущности. Фактически класс является образцом для создания новых объектов или сущностей (формулой или руководством по эксплуатации). Обычноклассыотносятсякстатичнымсущностям,существующимвкодеинеизменнымвпроцессевыполнения. Вотличииотобъектов,классыобычнонесодержатданных.Передачаданных классу позволяет создавать объекты, описанного в классе типа (в ООП понятия типданныхикласс-синонимы). Объект, созданный по образцу класса называют экземпляром этого класса. Основное предназначение классов - определять поведение своих экземпляров. Обычноклассысоздаюттакимобразом,чтобыониописывалиобъектыпредметнойобласти(объектыреальногомира). Классы позволяют описывать одинаковые сущности только один раз, уменьшаяэтимразмерыисложностьпрограммы.

Объект:
В основе ООП находится понятие объекта. Объект - это абстракция изменяемогосостоянияпамятикомпьютера.Обычнообъектыотносятсякдинамичным сущностям,создаваемымиизменяемымвпроцессевыполненияпрограммы. Объектыобладаютсостояниемиповедением. Состояниеобъектазависитотзначенияегосвойств(хранимыхобъектомданных). Поведение объекта зависит от набора доступных ему методов. Методы - это сообщения,которымиобмениваютсяобъекты.Этоабстрактныесущности,определяющие действия, которые можно выполнить над объектом и действия, которые сам объект может выполнять. Пользуясь методами объекта мы можем влиятьнаегосостояние,апосылаясообщенияклассумыможемизменятьсостояние всехегоэкземпляров. Таким образом ООП оперирует состоянием, заключенным внутри объекта, и позволяетвлиятьнанегоспомощьюпредоставленныхметодов. Создание объектов позволяет уменьшить сложность программы, акцентируя вниманиетольконаиспользующихсясущностяхиихвзаимодействии.

Инкапсуляция:
Инкапсуляция - это механизм языка, позволяющий сущности объединять в себеданныеиметодыдляработысэтимиданными.Данныеприэтомскрытыот остальнойпрограммы,аметодыдоступныдлявзаимодействияобъектов.Объект несчитаетсяотдельнойсущностью,еслиегосостояниеможетбытьизмененобез явногоиспользованияссылкинаобъект. 
• Инкапсуляция позволяет распараллелить процессы создания программы, ускоряяразработкуПО;
• Инкапсуляция снижает сложность разработки, позволяя сосредоточиться нанебольшихфрагментахпрограммы; 
• Инкапсуляция помогает сокрытию деталей реализации, необходимых программе,новыходящихзарамкиабстракции.Инкапсуляцияпомогаетуправлятьсложностью,скрываядоступкней.

Наследование:
Наследование - это механизм языка, позволяющий сущности использовать структуру другой сущности, заимствуя и расширяя уже имеющуюся функциональность(напримерклассырасширяютвозможностимодулей).Класс,который заимствуется(наследуется)называетсябазовымилисуперклассом,акласс,который заимствует (наследует) - производным или подклассом. Все базовые и производныеклассывобщемсоздаютиерархиюклассовпрограммы. • Наследованиеснижаетвремянаразработкузасчетповторногоиспользованиякода; • Наследование снижает сложность, позволяя использовать уже известные фрагменты программы. Однако при сложной иерархии повышается объем кода,скоторымработаетпрограммиствотдельныймоментвремени; • Наследованиедополняетабстракцию,выделяясущностиснезначительным уровнем различий. Наследование позволяет создавать абстракции с различным уровнем реализации (дополнительными группами существенных свойств).

Полиморфизм:
Полиморфизм - это механизм языка, позволяющий производным классов изменятьунаследованноеповедениессохранениемобщейструктуры. • Полиморфизм повышает скорость разработки, позволяя быстро подстраиватьсяподтребованиязаказчика; • Полиморфизм снижает сложность, позволяя скрывать внутреннюю структуруобъектов; • Полиморфизм поддерживает возможность отдельной реализации базовых методовдляпроизводныхклассов.

Типизацияданных:
ВRubyприменяетсястрогаядинамическаянеявнаятипизация. Пристрогойтипизациисовместимостьиграницыиспользованиятипаобъектаконтролируютсяинтерпретаторомикаждыйобъектимееттип(использование объектовнеподходящеготипасчитаетсяисключениемиприводиткзавершению выполненияпрограммы). При динамической (полиморфной) типизации тип объекта вычисляется во время выполнения и может произвольно изменяться в процессе. Динамическая типизацияоблегчаетреализациюполиморфизма. При неявной (утиной) типизации (подвид динамической типизации) совместимость и границы использования объекта ограничены его текущим набором методов и свойств, в противоположность наследованию от определенного класса.Утинаятипизацияставитвоглавуугланетипобъекта,аеговозможности. ДлятогочтобывRubyузнатьвозможностьиспользованиятогоилииногообъекта проверяется не его класс, а его реакция на вызов определенных методов в текущиймомент.Еслиреакцияобъектаудовлетворяетусловию,тоегоиспользованиеразрешается.

=====================================================================
puts print - Оператор print не переносит строку \n
спец символы \n новая сторка \t табуляция \r возвращает курсор в начало строки
типы данных- to_i-целое число, to_f-число с точкой, to_s-строка "", '',
Fixnum, Float, String, Bignum- числа больше 2 в 30степени
to_a -масив (1..5).to_a
gets -При вводе важно указывать тип данных
chomp - удаляет символ переноса строки \n \r
strip - удаляет пробелы и сиволы строк \n \r
Как определить тип данных в Ruby ? Запустить irb и проверить пример: 3.14.class
irb "x".methods 2.methods -вывод списка операций
Документация: http://ruby-doc.org/core-2.3.1/
интерполяция строк "#{}" 
=== строгое сравнение позволяет сравнивать разные типы объектов
== обычное сравнение
= присваивание
&& и
|| или
range - диапазон range(1...10).each{|x| p x} (1..3).each{|x| p x}
ruby gui http://shoesrb.com/
lambda это указатель на функцию, с последующим ее применением
функция метод процедура - одно и тоже  def end
геттеры - возращают значение свойств объекта
сеттеры - устанавливают значение свойств объекта
метод initialize автоматически вызывается при создание объекта
Внутри метода все переменные определяются заново
@a - глобальная переменная
return возвратить значение из метода
по умолчанию руби возвращает результат последнего выражения return можно опускать
объекты и экземпляры класа (instance) все хранится в памяти(heap) 
символы :a сивол в памяти размещен в 1 месте
a.object_id  :a.object_id
yield вызов
lambda -указатель на функцию
массив - набор объектов любого типа
Обменять значения 2 переменных без использования 3
a = 1
b = 2
a,b = b,a
p a,b

a = a+b
b = a-b
a = a-b

===================================================
+/- Ruby/Ruby on Rails
Ruby/Ruby on Rails версии
MRI Rubinius JRuby Gil
Http ?
http server
block prock lambda
Paterns
sql db indexes
rake
Sync/Async ruby,
message queues
web servers puma thin unicorn
microservices - pains and best practices
deploy devops stuff
cluster lb
distributed database consensus algorithms wal